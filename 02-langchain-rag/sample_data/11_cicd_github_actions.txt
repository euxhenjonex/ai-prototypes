CI/CD and GitHub Actions: Automating Software Delivery

Continuous Integration and Continuous Deployment (CI/CD) are practices that automate the process of testing, building, and deploying software. GitHub Actions is GitHub's built-in CI/CD platform that makes automation accessible and powerful.

What is CI/CD?

Continuous Integration (CI):
- Automatically test code on every commit/PR
- Catch bugs early
- Ensure code quality
- Verify builds work
- Run linters and formatters

Continuous Deployment (CD):
- Automatically deploy passing code
- Deploy to staging/production
- Build and publish Docker images
- Update documentation
- Create releases

Benefits:
- Faster development cycle
- Fewer bugs in production
- Consistent builds
- Automated quality checks
- Reduced manual work

Why GitHub Actions?

Advantages:
1. Built into GitHub (no third-party service needed)
2. Free for public repos (generous limits for private)
3. Simple YAML syntax
4. Huge marketplace of pre-built actions
5. Matrix builds (test multiple versions)
6. Secrets management
7. Rich integration with GitHub features

Alternatives:
- Jenkins (self-hosted, very flexible)
- GitLab CI (integrated with GitLab)
- CircleCI (cloud-based)
- Travis CI (popular for open source)

GitHub Actions Concepts:

1. Workflow
YAML file defining automation:
- Located in .github/workflows/
- Triggered by events (push, PR, schedule, etc.)
- Contains one or more jobs

2. Event
Triggers that start workflows:
- push: Code pushed to repository
- pull_request: PR opened/updated
- schedule: Run on a schedule (cron)
- workflow_dispatch: Manual trigger
- release: Release created

3. Job
Set of steps that run on same runner:
- Runs on fresh virtual machine
- Can run in parallel or sequentially
- Can depend on other jobs

4. Step
Individual task in a job:
- Run command
- Use an action
- Checkout code
- Set up environment

5. Runner
Server that runs workflows:
- GitHub-hosted (Ubuntu, Windows, macOS)
- Self-hosted (your own infrastructure)

6. Action
Reusable unit of code:
- From marketplace
- Custom actions
- Composite actions

Basic Workflow Example:

.github/workflows/test.yml:
```yaml
name: Tests

# When to run
on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

# Jobs to run
jobs:
  test:
    # Runner environment
    runs-on: ubuntu-latest

    # Steps to execute
    steps:
      # Checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # Setup Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      # Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov

      # Run tests
      - name: Run tests
        run: pytest --cov=app --cov-report=xml

      # Upload coverage
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
```

Advanced Workflow Features:

1. Matrix Strategy
Test multiple versions:
```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11', '3.12']

    steps:
      - uses: actions/checkout@v3
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      - name: Run tests
        run: pytest
```

This creates 4 jobs, one for each Python version.

2. Conditional Execution
```yaml
steps:
  - name: Deploy to production
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    run: ./deploy.sh

  - name: Comment on PR
    if: github.event_name == 'pull_request'
    run: echo "Thanks for the PR!"
```

3. Job Dependencies
```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - run: pytest

  deploy:
    needs: test  # Only runs if test succeeds
    runs-on: ubuntu-latest
    steps:
      - run: ./deploy.sh
```

4. Artifacts
Share files between jobs:
```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Build app
        run: ./build.sh
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: my-app
          path: dist/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: my-app
      - name: Deploy
        run: ./deploy.sh
```

5. Caching
Speed up workflows:
```yaml
steps:
  - name: Cache Python dependencies
    uses: actions/cache@v3
    with:
      path: ~/.cache/pip
      key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
      restore-keys: |
        ${{ runner.os }}-pip-

  - name: Install dependencies
    run: pip install -r requirements.txt
```

Secrets Management:

Store sensitive data securely:

1. Add secrets in GitHub:
   - Settings → Secrets and variables → Actions
   - Click "New repository secret"
   - Name: OPENAI_API_KEY, Value: sk-...

2. Use in workflow:
```yaml
steps:
  - name: Run tests
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    run: pytest
```

Never commit secrets to repository!

Complete CI/CD Pipeline Example:

.github/workflows/ci-cd.yml:
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # Linting and code quality
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          pip install ruff black isort
      - name: Run ruff
        run: ruff check .
      - name: Check formatting
        run: black --check .
      - name: Check imports
        run: isort --check-only .

  # Unit and integration tests
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11']

    steps:
      - uses: actions/checkout@v3
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio

      - name: Run tests
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: pytest --cov=app --cov-report=xml --cov-report=term

      - name: Upload coverage
        if: matrix.python-version == '3.11'
        uses: codecov/codecov-action@v3

  # Build Docker image
  build:
    needs: [lint, test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push'

    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: yourusername/your-app
          tags: |
            type=ref,event=branch
            type=sha

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to production
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v3

      - name: Deploy to production
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          # Your deployment script
          echo "Deploying to production..."
          # ./deploy.sh
```

Docker Build and Push Workflow:

.github/workflows/docker.yml:
```yaml
name: Docker Build and Push

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            yourusername/app:latest
            yourusername/app:${{ github.sha }}
```

Automated Release Workflow:

.github/workflows/release.yml:
```yaml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false

      - name: Build artifacts
        run: |
          # Build your application
          python setup.py sdist bdist_wheel

      - name: Upload to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
```

Scheduled Workflows:

Run on a schedule (cron):
```yaml
name: Nightly Tests

on:
  schedule:
    # Runs at 2:00 AM UTC every day
    - cron: '0 2 * * *'
  workflow_dispatch:  # Allow manual trigger

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run extensive tests
        run: pytest --slow
```

Status Badges:

Add to README.md:
```markdown
![Tests](https://github.com/username/repo/workflows/Tests/badge.svg)
![Docker](https://github.com/username/repo/workflows/Docker/badge.svg)
[![codecov](https://codecov.io/gh/username/repo/branch/main/graph/badge.svg)](https://codecov.io/gh/username/repo)
```

Best Practices:

1. Fail Fast
- Run fastest tests first
- Run linting before tests
- Cancel redundant workflows

2. Use Caching
- Cache dependencies
- Cache Docker layers
- Use GitHub cache action

3. Matrix Testing
- Test multiple Python versions
- Test on different OS
- Test with different dependencies

4. Secure Secrets
- Never commit secrets
- Use GitHub secrets
- Rotate secrets regularly

5. Optimize for Speed
- Parallel jobs when possible
- Use caching
- Use concurrency limits

6. Clear Naming
- Descriptive job names
- Clear step descriptions
- Organized workflow files

7. Monitoring
- Set up notifications
- Monitor workflow duration
- Track failure rates

8. Documentation
- Document required secrets
- Explain workflow purpose
- Include setup instructions

Common Workflows for AI/ML Projects:

1. Model Training Pipeline
```yaml
name: Train Model

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly

jobs:
  train:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Train model
        run: python train.py
      - name: Upload model artifact
        uses: actions/upload-artifact@v3
        with:
          name: model
          path: models/
```

2. API Performance Testing
```yaml
name: Load Tests

on:
  pull_request:
    paths:
      - 'app/**'

jobs:
  load-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Start API
        run: docker-compose up -d
      - name: Run load tests
        run: locust --headless --users 100 --spawn-rate 10
```

3. Documentation Updates
```yaml
name: Update Docs

on:
  push:
    branches: [ main ]
    paths:
      - 'docs/**'

jobs:
  deploy-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs
```

Debugging Workflows:

1. Use workflow_dispatch for manual testing:
```yaml
on:
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug logging'
        required: false
        default: 'false'
```

2. Enable debug logging:
   - Settings → Secrets → Add ACTIONS_STEP_DEBUG = true

3. Use tmate for SSH debugging:
```yaml
- name: Setup tmate session
  if: failure()
  uses: mxschmitt/action-tmate@v3
```

Cost Considerations:

GitHub Actions is free for public repos with limits:
- Private repos: 2,000 minutes/month (free tier)
- Public repos: Unlimited

Optimize costs:
- Use caching effectively
- Cancel redundant runs
- Use matrix builds wisely
- Self-host runners for heavy usage

CI/CD with GitHub Actions automates quality checks and deployments, making your development process faster, more reliable, and more professional. For portfolios and job applications, having well-configured CI/CD demonstrates production-ready skills that recruiters value highly.
