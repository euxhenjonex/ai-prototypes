=== APIs EXPLAINED SIMPLY: A BEGINNER'S GUIDE ===

If you're getting into AI engineering, you'll work with APIs constantly - calling AI models, fetching data, and building your own services. Let's demystify what APIs are and how they work, with practical examples relevant to AI.

## What is an API?

**API** stands for **Application Programming Interface**. Think of it as a waiter in a restaurant:

- **You (the client)** sit at a table and look at the menu
- **The waiter (the API)** takes your order to the kitchen
- **The kitchen (the server)** prepares your meal
- **The waiter** brings your food back to you

You don't need to know how the kitchen works - you just need to know how to order from the menu. Similarly, with an API, you don't need to know how a service works internally; you just need to know how to make requests and interpret responses.

## Why APIs Matter in AI

In modern AI development, APIs are everywhere:

1. **Calling AI Models**: OpenAI's GPT, Anthropic's Claude, Google's Gemini - all accessed via APIs
2. **Vector Databases**: Pinecone, Weaviate, Qdrant - API-based services
3. **Data Sources**: Weather data, news feeds, social media - accessed through APIs
4. **Deployment**: Your own AI models are deployed as APIs so others can use them

## REST APIs: The Standard

**REST** (Representational State Transfer) is the most common API architecture. Think of it as a set of rules for how web services communicate.

### Key Principles of REST:

1. **Resource-Based**: Everything is a "resource" identified by a URL
   - Example: `https://api.example.com/users/123`
   - Example: `https://api.openai.com/v1/chat/completions`

2. **Stateless**: Each request contains all the information needed
   - The server doesn't remember previous requests
   - Every request is independent

3. **Standard HTTP Methods**: Uses familiar web verbs
   - **GET**: Retrieve data (like reading)
   - **POST**: Create new data (like submitting a form)
   - **PUT**: Update existing data (like editing)
   - **DELETE**: Remove data
   - **PATCH**: Partially update data

## HTTP Methods Explained with AI Examples

### GET - Retrieve Information

Used when you want to fetch data without changing anything.

**Example: Get Model Information**
```
GET https://api.ai-service.com/models/gpt-4
```

This might return:
```json
{
  "model": "gpt-4",
  "max_tokens": 8192,
  "training_data": "Up to Sep 2021"
}
```

**Python Example:**
```python
import requests

response = requests.get("https://api.ai-service.com/models/gpt-4")
model_info = response.json()
print(f"Max tokens: {model_info['max_tokens']}")
```

### POST - Send Data and Get a Response

Most common for AI applications - you send a prompt and get a response.

**Example: Query an AI Model**
```
POST https://api.openai.com/v1/chat/completions
Content-Type: application/json
Authorization: Bearer YOUR_API_KEY

{
  "model": "gpt-4o-mini",
  "messages": [
    {"role": "user", "content": "Explain machine learning in simple terms"}
  ],
  "max_tokens": 100
}
```

**Python Example:**
```python
import requests

url = "https://api.openai.com/v1/chat/completions"
headers = {
    "Authorization": "Bearer YOUR_API_KEY",
    "Content-Type": "application/json"
}
data = {
    "model": "gpt-4o-mini",
    "messages": [
        {"role": "user", "content": "Explain machine learning"}
    ],
    "max_tokens": 100
}

response = requests.post(url, headers=headers, json=data)
result = response.json()
print(result["choices"][0]["message"]["content"])
```

### PUT - Replace Entire Resource

Used to completely replace an existing resource.

**Example: Update Vector Database Record**
```
PUT https://api.vectordb.com/collections/docs/vectors/123

{
  "id": "123",
  "vector": [0.1, 0.2, 0.3, ...],
  "metadata": {"title": "New Title", "author": "Jane"}
}
```

### PATCH - Partial Update

Update only specific fields of a resource.

**Example: Update Model Settings**
```
PATCH https://api.ai-service.com/deployments/my-model

{
  "temperature": 0.8,
  "max_tokens": 500
}
```

### DELETE - Remove Resource

**Example: Delete a Fine-tuned Model**
```
DELETE https://api.openai.com/v1/models/ft:gpt-3.5:my-model
```

## Understanding JSON: The Language of APIs

**JSON** (JavaScript Object Notation) is the format most APIs use to exchange data. It's human-readable and easy to work with.

### JSON Structure:

```json
{
  "string": "This is text",
  "number": 42,
  "decimal": 3.14,
  "boolean": true,
  "null_value": null,
  "array": [1, 2, 3, 4],
  "nested_object": {
    "key": "value",
    "another_key": "another value"
  }
}
```

### Real AI API Response Example:

```json
{
  "id": "chatcmpl-123",
  "object": "chat.completion",
  "created": 1677652288,
  "model": "gpt-4o-mini",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Machine learning is a type of AI that enables computers to learn from data and improve over time without being explicitly programmed."
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 13,
    "completion_tokens": 25,
    "total_tokens": 38
  }
}
```

### Working with JSON in Python:

```python
import json

# Convert JSON string to Python dict
json_string = '{"name": "GPT-4", "version": 4}'
data = json.loads(json_string)
print(data["name"])  # Output: GPT-4

# Convert Python dict to JSON string
my_data = {"model": "gpt-4", "temperature": 0.7}
json_output = json.dumps(my_data, indent=2)
print(json_output)
```

## HTTP Status Codes: Understanding Responses

APIs use standard HTTP status codes to tell you what happened:

### Success Codes (2xx)
- **200 OK**: Request succeeded
- **201 Created**: New resource created successfully
- **204 No Content**: Success, but no data to return

### Client Error Codes (4xx)
- **400 Bad Request**: Your request was malformed
- **401 Unauthorized**: Missing or invalid authentication
- **403 Forbidden**: You don't have permission
- **404 Not Found**: Resource doesn't exist
- **429 Too Many Requests**: You're being rate limited

### Server Error Codes (5xx)
- **500 Internal Server Error**: Something went wrong on their end
- **503 Service Unavailable**: Service is temporarily down

**Python Example with Error Handling:**
```python
import requests

def safe_api_call(url, api_key):
    headers = {"Authorization": f"Bearer {api_key}"}

    try:
        response = requests.get(url, headers=headers, timeout=10)

        if response.status_code == 200:
            return {"success": True, "data": response.json()}
        elif response.status_code == 401:
            return {"success": False, "error": "Invalid API key"}
        elif response.status_code == 429:
            return {"success": False, "error": "Rate limit exceeded. Wait and retry."}
        elif response.status_code == 500:
            return {"success": False, "error": "Server error. Try again later."}
        else:
            return {"success": False, "error": f"Unexpected status: {response.status_code}"}

    except requests.exceptions.Timeout:
        return {"success": False, "error": "Request timed out"}
    except requests.exceptions.ConnectionError:
        return {"success": False, "error": "Could not connect to API"}
```

## Authentication: Proving Who You Are

APIs need to know who's making requests. Common authentication methods:

### 1. API Keys (Most Common)

Simple string you include in requests.

**In Headers:**
```python
headers = {
    "Authorization": "Bearer sk-your-api-key-here",
    "Content-Type": "application/json"
}
requests.post(url, headers=headers, json=data)
```

**In Query Parameters:**
```python
params = {"api_key": "your-key-here"}
requests.get(url, params=params)
```

**Security Best Practice:**
Never hardcode API keys! Use environment variables:
```python
import os
API_KEY = os.getenv("OPENAI_API_KEY")
```

### 2. OAuth 2.0 (More Secure)

Used for accessing user data on behalf of users (like "Sign in with Google").

```python
# OAuth typically involves multiple steps
# 1. Redirect user to provider's login
# 2. User authorizes your app
# 3. Provider gives you an access token
# 4. Use token in subsequent requests

headers = {
    "Authorization": "Bearer ACCESS_TOKEN_HERE"
}
```

### 3. Basic Authentication

Username and password encoded together (rarely used for modern APIs).

```python
import requests
from requests.auth import HTTPBasicAuth

response = requests.get(
    url,
    auth=HTTPBasicAuth('username', 'password')
)
```

## Rate Limiting: Playing Nice with APIs

APIs limit how many requests you can make to prevent abuse and ensure fair usage.

**Common Limits:**
- **Requests per minute**: e.g., 60 requests/minute
- **Requests per day**: e.g., 10,000 requests/day
- **Tokens per minute** (for AI APIs): e.g., 90,000 tokens/minute

**Handling Rate Limits:**
```python
import time
import requests

def call_api_with_retry(url, headers, data, max_retries=3):
    for attempt in range(max_retries):
        response = requests.post(url, headers=headers, json=data)

        if response.status_code == 200:
            return response.json()
        elif response.status_code == 429:
            # Rate limited - wait and retry
            wait_time = int(response.headers.get("Retry-After", 60))
            print(f"Rate limited. Waiting {wait_time} seconds...")
            time.sleep(wait_time)
        else:
            raise Exception(f"API error: {response.status_code}")

    raise Exception("Max retries exceeded")
```

## Testing APIs: Tools and Techniques

### 1. curl (Command Line)

Test APIs directly from terminal:

```bash
# GET request
curl https://api.example.com/models

# POST request with data
curl -X POST https://api.example.com/query \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_KEY" \
  -d '{"question": "What is AI?"}'
```

### 2. Postman (GUI Tool)

Popular application for testing APIs visually:
- Create and save requests
- Organize requests in collections
- View formatted responses
- Generate code snippets in various languages

### 3. Python requests Library

Best for automating tests:

```python
import requests

# Test health endpoint
def test_health():
    response = requests.get("http://localhost:8000/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"
    print("✓ Health check passed")

# Test query endpoint
def test_query():
    data = {"question": "What is machine learning?"}
    response = requests.post(
        "http://localhost:8000/query",
        json=data
    )
    assert response.status_code == 200
    result = response.json()
    assert "answer" in result
    print("✓ Query test passed")

if __name__ == "__main__":
    test_health()
    test_query()
```

## Building Your Own API with FastAPI

Now that you understand how to *use* APIs, let's see how to *build* one!

**Simple FastAPI Example:**

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()

# Define data model
class Question(BaseModel):
    text: str

class Answer(BaseModel):
    question: str
    answer: str

# Health check endpoint
@app.get("/health")
async def health():
    return {"status": "healthy"}

# Query endpoint
@app.post("/query", response_model=Answer)
async def query(question: Question):
    # In real app, this would call your AI model
    answer_text = f"This is a response to: {question.text}"

    return Answer(
        question=question.text,
        answer=answer_text
    )

# Run with: uvicorn main:app --reload
```

**Test it:**
```bash
curl -X POST http://localhost:8000/query \
  -H "Content-Type: application/json" \
  -d '{"text": "What is AI?"}'
```

## Common API Patterns in AI Applications

### 1. Synchronous Request-Response
Most common - send request, wait for response.

```python
response = requests.post(api_url, json=data)
result = response.json()
```

**Use for:** Single queries, real-time interactions

### 2. Asynchronous/Webhook Pattern
For long-running tasks, API returns immediately with a job ID. You check status later or receive a webhook callback.

```python
# Start job
response = requests.post(api_url, json=data)
job_id = response.json()["job_id"]

# Check status later
status_response = requests.get(f"{api_url}/jobs/{job_id}")
if status_response.json()["status"] == "completed":
    result = status_response.json()["result"]
```

**Use for:** Video processing, large document analysis, model training

### 3. Streaming Responses
Receive data in chunks as it's generated (common with ChatGPT-style interfaces).

```python
import requests

url = "https://api.openai.com/v1/chat/completions"
headers = {"Authorization": f"Bearer {API_KEY}"}
data = {
    "model": "gpt-4",
    "messages": [{"role": "user", "content": "Tell me a story"}],
    "stream": True
}

response = requests.post(url, headers=headers, json=data, stream=True)

for line in response.iter_lines():
    if line:
        # Process each chunk as it arrives
        print(line.decode('utf-8'))
```

**Use for:** Chatbots, real-time text generation

## Best Practices for Working with APIs

1. **Always handle errors**: Network issues, timeouts, and API errors are inevitable
2. **Respect rate limits**: Implement backoff and retry logic
3. **Never expose API keys**: Use environment variables, never commit to version control
4. **Validate responses**: Check status codes and response structure
5. **Set timeouts**: Prevent indefinite hangs with `timeout` parameter
6. **Log requests**: For debugging and monitoring
7. **Cache when possible**: Reduce API calls by caching frequent queries
8. **Read the documentation**: Every API is different - RTFM!

## Real-World AI API Example: Building a RAG System

Putting it all together - here's how you'd use multiple APIs in a RAG application:

```python
import os
import requests
from typing import List

# Environment variables
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
PINECONE_API_KEY = os.getenv("PINECONE_API_KEY")

def get_embeddings(text: str) -> List[float]:
    """Get embeddings from OpenAI API"""
    url = "https://api.openai.com/v1/embeddings"
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": "text-embedding-ada-002",
        "input": text
    }

    response = requests.post(url, headers=headers, json=data)
    response.raise_for_status()

    return response.json()["data"][0]["embedding"]

def search_similar_docs(query_vector: List[float], top_k: int = 3):
    """Search Pinecone vector database"""
    url = "https://your-index.pinecone.io/query"
    headers = {
        "Api-Key": PINECONE_API_KEY,
        "Content-Type": "application/json"
    }
    data = {
        "vector": query_vector,
        "topK": top_k,
        "includeMetadata": True
    }

    response = requests.post(url, headers=headers, json=data)
    response.raise_for_status()

    return response.json()["matches"]

def generate_answer(question: str, context: str) -> str:
    """Generate answer using OpenAI"""
    url = "https://api.openai.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": "gpt-4o-mini",
        "messages": [
            {
                "role": "system",
                "content": "Answer based on the context provided."
            },
            {
                "role": "user",
                "content": f"Context: {context}\n\nQuestion: {question}"
            }
        ]
    }

    response = requests.post(url, headers=headers, json=data)
    response.raise_for_status()

    return response.json()["choices"][0]["message"]["content"]

def rag_query(question: str) -> str:
    """Complete RAG pipeline"""
    # 1. Get question embedding
    query_vector = get_embeddings(question)

    # 2. Search vector database
    matches = search_similar_docs(query_vector)

    # 3. Extract context from matches
    context = "\n\n".join([match["metadata"]["text"] for match in matches])

    # 4. Generate answer
    answer = generate_answer(question, context)

    return answer

# Usage
answer = rag_query("What is retrieval augmented generation?")
print(answer)
```

## Summary

APIs are the backbone of modern software, especially in AI:

- **REST APIs** use HTTP methods (GET, POST, PUT, DELETE) to interact with resources
- **JSON** is the standard format for data exchange
- **Status codes** tell you if your request succeeded or why it failed
- **Authentication** (usually API keys) proves who you are
- **Rate limiting** prevents abuse and ensures fair usage
- **Error handling** is essential for robust applications

Understanding APIs empowers you to:
- Integrate AI models into your applications
- Build your own AI services that others can use
- Debug issues when things go wrong
- Make informed architecture decisions

Start by experimenting with a simple API, then gradually build more complex integrations. The best way to learn is by doing! 🚀
